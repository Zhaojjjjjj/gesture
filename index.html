<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>AR Hand Tracking</title>
		<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ‘‹</text></svg>" />
		<style>
			body {
				margin: 0;
				display: flex;
				justify-content: center;
				align-items: center;
				height: 100vh;
				background-color: #222;
				overflow: hidden;
			}

			/* ç”¨äºæ˜¾ç¤ºæ‘„åƒå¤´è¾“å…¥çš„è§†é¢‘å…ƒç´  */
			#video-feed {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				object-fit: cover;
				transform: scaleX(-1); /* é•œåƒï¼Œæ›´ç¬¦åˆè‡ªæ‹è§†è§’ */
			}

			/* ç”¨äºè¦†ç›–åœ¨è§†é¢‘ä¸Šæ–¹çš„ AR æ¸²æŸ“åŒºåŸŸ */
			#overlay-canvas {
				position: absolute;
				top: 0;
				left: 0;
				transform: scaleX(-1); /* ä¿æŒä¸è§†é¢‘ä¸€è‡´çš„é•œåƒ */
			}

			/* æç¤ºä¿¡æ¯ */
			#loading {
				color: white;
				font-size: 24px;
				z-index: 10;
			}
		</style>
		<script type="importmap">
			{
				"imports": {
					"@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
				}
			}
		</script>
	</head>
	<body>
		<div id="loading">æ­£åœ¨åŠ è½½æ¨¡å‹ï¼Œè¯·ç¨å€™...</div>
		<video id="video-feed" autoplay playsinline></video>
		<canvas id="overlay-canvas"></canvas>

		<script type="module">
			import { FilesetResolver, HandLandmarker } from "@mediapipe/tasks-vision";

			const video = document.getElementById("video-feed");
			const canvas = document.getElementById("overlay-canvas");
			const ctx = canvas.getContext("2d");
			const loadingText = document.getElementById("loading");

			// MediaPipe ç›¸å…³å˜é‡
			let handLandmarker;
			let lastVideoTime = -1;
			let runningMode = "VIDEO";

			// AR æ–‡æœ¬é€»è¾‘ç›¸å…³å˜é‡
			const TARGET_WORD = "COOKING";
			let renderedLetters = {}; // å­˜å‚¨å·²æ¸²æŸ“çš„å­—æ¯: { 'C': {x: 100, y: 200, drawn: true}, ... }
			let nextLetterIndex = 0;
			const TRIGGER_ZONES = [
				{ name: "C", xMin: 0.1, xMax: 0.3 }, // å·¦ä¾§åŒºåŸŸ
				{ name: "O1", xMin: 0.3, xMax: 0.5 }, // å·¦ä¸­åŒºåŸŸ
				{ name: "O2", xMin: 0.5, xMax: 0.7 }, // å³ä¸­åŒºåŸŸ
				// æ›´å¤šå­—æ¯...
			];

			/**
			 * åˆå§‹åŒ– MediaPipe HandLandmarker æ¨¡å‹
			 */
			async function createHandLandmarker() {
				try {
					const vision = await FilesetResolver.forVisionTasks(
						"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
					);
					handLandmarker = await HandLandmarker.createFromOptions(vision, {
						baseOptions: {
							modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
							delegate: "GPU",
						},
						runningMode: runningMode,
						numHands: 1,
					});

					loadingText.style.display = "none";
					setupCamera();
				} catch (error) {
					console.error("æ¨¡å‹åŠ è½½å¤±è´¥:", error);
					loadingText.textContent = "æ¨¡å‹åŠ è½½å¤±è´¥: " + error.message;
				}
			}

			/**
			 * è®¾ç½®æ‘„åƒå¤´å¹¶å¼€å§‹è§†é¢‘æµ
			 */
			function setupCamera() {
				navigator.mediaDevices
					.getUserMedia({ video: true })
					.then((stream) => {
						video.srcObject = stream;
						video.addEventListener("loadeddata", () => {
							// è®¾ç½®ç”»å¸ƒå°ºå¯¸ä¸è§†é¢‘æµä¸€è‡´
							canvas.width = video.videoWidth;
							canvas.height = video.videoHeight;
							video.play();
							requestAnimationFrame(predictLoop); // å¼€å§‹é¢„æµ‹å¾ªç¯
						});
					})
					.catch((err) => {
						console.error("æ— æ³•è·å–æ‘„åƒå¤´: ", err);
						loadingText.textContent = "æ— æ³•è·å–æ‘„åƒå¤´æƒé™ã€‚";
					});
			}

			/**
			 * å®æ—¶é¢„æµ‹å’Œ AR æ¸²æŸ“å¾ªç¯
			 */
			function predictLoop() {
				if (runningMode === "VIDEO" && handLandmarker) {
					let startTimeMs = performance.now();
					if (lastVideoTime !== video.currentTime) {
						// è¿›è¡Œæ‰‹éƒ¨å§¿æ€é¢„æµ‹
						const results = handLandmarker.detectForVideo(video, startTimeMs);
						lastVideoTime = video.currentTime;

						ctx.clearRect(0, 0, canvas.width, canvas.height);

						if (results.handLandmarks && results.handLandmarks.length > 0) {
							const landmarks = results.handLandmarks[0];
							// è·å–æ‰‹éƒ¨ä¸­å¿ƒç‚¹ (ä»¥é£ŸæŒ‡æŒ‡å°–ä¸ºä¾‹ï¼Œç´¢å¼• 8)
							const indexFingerTip = landmarks[8];

							// å°†æ ‡å‡†åŒ–åæ ‡ (0~1) è½¬æ¢ä¸ºåƒç´ åæ ‡
							const xPixel = indexFingerTip.x * canvas.width;
							const yPixel = indexFingerTip.y * canvas.height;

							// ç»˜åˆ¶ä¸€ä¸ªç‚¹ä½œä¸ºæ‰‹çš„æ ‡è®°
							drawHandMarker(xPixel, yPixel);

							// æ‰§è¡Œ AR æ–‡æœ¬ç”Ÿæˆé€»è¾‘
							processARLogic(xPixel, yPixel);
						}
					}
				}
				requestAnimationFrame(predictLoop);
			}

			/**
			 * ç»˜åˆ¶æ‰‹éƒ¨æ ‡è®° (ä»£æ›¿è§†é¢‘ä¸­çš„ C å½¢ç‰©ä½“)
			 */
			function drawHandMarker(x, y) {
				ctx.beginPath();
				ctx.arc(x, y, 10, 0, 2 * Math.PI);
				ctx.fillStyle = "red"; // çº¢è‰²æ ‡è®°æ‰‹çš„ä½ç½®
				ctx.fill();
				ctx.closePath();
			}

			/**
			 * AR æ–‡æœ¬ç”Ÿæˆæ ¸å¿ƒé€»è¾‘
			 */
			function processARLogic(handX, handY) {
				const nextLetter = TARGET_WORD[nextLetterIndex];

				if (!nextLetter) {
					// å•è¯å·²å®Œæˆï¼Œåªéœ€é‡æ–°ç»˜åˆ¶å·²æœ‰çš„å­—æ¯
					redrawLetters();
					return;
				}

				// æ£€æŸ¥æ˜¯å¦è¾¾åˆ°è§¦å‘æ¡ä»¶ (ç®€åŒ–ä¸ºæ‰‹éƒ¨åœ¨å±å¹•çš„å·¦ä¾§/ä¸­é—´/å³ä¾§è§¦å‘)
				// æ³¨æ„ï¼šåœ¨å®é™…åº”ç”¨ä¸­ï¼Œæ‚¨ä¼šæ ¹æ® YOLO çš„è¾“å‡ºåæ ‡å’Œæ‰‹åŠ¿æ¥å®šä¹‰æ›´å¤æ‚çš„é€»è¾‘

				// ç®€åŒ–è§¦å‘é€»è¾‘ï¼šåªè¦æ‰‹å‡ºç°åœ¨å±å¹•çš„å·¦åŠéƒ¨åˆ†ï¼Œå°±å†™ä¸‹ä¸€ä¸ªå­—æ¯
				const triggerCondition = handX < canvas.width / 2;

				if (triggerCondition && !renderedLetters[nextLetter]) {
					// è§¦å‘æ–°çš„å­—æ¯ç”Ÿæˆ

					// å­—æ¯çš„ä½ç½®åº”æ”¾åœ¨å½“å‰æ‰‹éƒ¨é™„è¿‘ï¼Œä½†ç¨å¾®åä¸Šï¼Œå¹¶å›ºå®šä¸‹æ¥
					const fixedX = handX;
					const fixedY = handY - 100; // ç¨å¾®æŠ¬é«˜ä¸€ç‚¹

					// å­˜å‚¨å­—æ¯åŠå…¶ä½ç½®
					renderedLetters[nextLetter] = {
						x: fixedX,
						y: fixedY,
						text: nextLetter,
					};

					// å‡†å¤‡ä¸‹ä¸€ä¸ªå­—æ¯
					nextLetterIndex++;
				}

				redrawLetters();
			}

			/**
			 * é‡æ–°ç»˜åˆ¶æ‰€æœ‰å·²ç”Ÿæˆçš„å­—æ¯
			 */
			function redrawLetters() {
				ctx.font = "bold 80px Arial";
				ctx.fillStyle = "white";
				ctx.textAlign = "center";

				Object.values(renderedLetters).forEach((letter) => {
					// è§†é¢‘ä¸­çš„æ–‡å­—æ˜¯æ¨ªå‘æ’åˆ—çš„ï¼Œæˆ‘ä»¬æ ¹æ®é¡ºåºé‡æ–°è®¡ç®—å®ƒä»¬çš„ä½ç½®ï¼Œä½¿å…¶æ•´é½
					const order = TARGET_WORD.indexOf(letter.text);

					if (order >= 0) {
						// å°†æ‰€æœ‰å­—æ¯æ’å¸ƒåœ¨ä¸€ä¸ªä¸­å¿ƒçº¿ä¸Š
						const textCenterY = canvas.height / 2;
						// æ–‡æœ¬èµ·å§‹ X ä½ç½® + åç§»é‡
						const textStartX = canvas.width / 2 - (TARGET_WORD.length * 40) / 2; // å‡è®¾æ¯ä¸ªå­—æ¯å®½åº¦çº¦ 40px
						const currentX = textStartX + order * 80; // é—´è· 80px

						ctx.fillText(letter.text, currentX, textCenterY);
					}
				});
			}

			// å¯åŠ¨ç¨‹åº
			createHandLandmarker();
		</script>
	</body>
</html>
